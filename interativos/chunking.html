<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Demonstra√ß√£o Interativa de Chunking - Mini-GPT Rust</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="css/design-system.css">
    <style>
        .chunk-item {
            background: white;
            border: 2px solid var(--secondary-200);
            border-radius: var(--radius-lg);
            padding: var(--space-md);
            margin-bottom: var(--space-sm);
            transition: all var(--transition-normal);
            opacity: 0;
            transform: translateY(20px);
            animation: fadeInUp 0.5s forwards;
            box-shadow: var(--shadow-sm);
        }
        
        .chunk-item:hover {
            border-color: var(--primary-300);
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }
        
        .chunk-fixed { border-left: 4px solid #10b981; }
        .chunk-semantic { border-left: 4px solid #3b82f6; }
        .chunk-adaptive { border-left: 4px solid #8b5cf6; }
        .chunk-overlap { border-left: 4px solid #f59e0b; }
        
        .scanner-line {
            position: absolute;
            top: 0;
            left: 0;
            width: 3px;
            height: 100%;
            background: var(--primary-500);
            box-shadow: 0 0 10px var(--primary-500);
            animation: scan 3s linear forwards;
        }
        
        @keyframes scan {
            from { transform: translateX(0%); }
            to { transform: translateX(calc(100% - 3px)); }
        }
        
        .chunk-highlight {
            position: absolute;
            top: 0;
            height: 100%;
            opacity: 0.3;
            transition: all var(--transition-normal);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--space-md);
            margin-top: var(--space-lg);
        }
        
        .stat-card {
            background: var(--gradient-cool);
            color: white;
            padding: var(--space-lg);
            border-radius: var(--radius-xl);
            text-align: center;
            box-shadow: var(--shadow-md);
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: 800;
            margin-bottom: var(--space-xs);
        }
        
        .stat-label {
            font-size: 0.875rem;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <!-- Header Principal -->
    <header class="page-header">
        <a href="/" class="back-button">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"></path>
            </svg>
            Voltar ao In√≠cio
        </a>
        
        <h1 class="page-title">üîó Demonstra√ß√£o de Chunking</h1>
        <p class="page-subtitle">
            Explore como diferentes algoritmos dividem texto em peda√ßos (chunks) para processamento eficiente em modelos de linguagem
        </p>
    </header>

    <div class="container">

        <main class="grid-layout">
            <!-- Painel de Controle -->
            <div class="space-y-6">
                <div class="control-panel">
                    <div class="form-group">
                        <label class="form-label">üìù Insira seu Texto</label>
                        <textarea id="inputText" class="form-input form-textarea" placeholder="Cole ou digite seu texto aqui...">O chunking √© o processo de dividir textos longos em peda√ßos menores e semanticamente significativos, chamados de chunks. Esta √© uma etapa crucial em pipelines de Processamento de Linguagem Natural, especialmente para aplica√ß√µes de Gera√ß√£o Aumentada por Recupera√ß√£o (RAG).

Existem v√°rias estrat√©gias para o chunking. A mais simples √© a de tamanho fixo, que corta o texto em segmentos de um tamanho pr√©-definido. Uma abordagem mais sofisticada √© a recursiva, que tenta dividir o texto por par√°grafos, depois por senten√ßas, e assim por diante, para manter a coes√£o.

A estrat√©gia mais avan√ßada √© o chunking sem√¢ntico. Este m√©todo utiliza modelos de embedding para "entender" o significado do texto e faz as divis√µes onde ocorrem mudan√ßas de t√≥pico, garantindo que cada chunk seja tematicamente coeso. A escolha do m√©todo correto impacta diretamente a qualidade do contexto fornecido ao LLM.</textarea>

                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">üîß Escolha o Algoritmo</label>
                        <div id="algorithmSelector" class="space-y-3">
                            <div class="radio-option">
                                <input type="radio" id="fixed" name="algorithm" value="fixed" class="radio-input" checked>
                                <label for="fixed" class="radio-label tooltip">
                                    <span class="radio-title">üìè Tamanho Fixo</span>
                                    <span class="radio-description">Divis√£o em peda√ßos de tamanho igual</span>
                                    <span class="tooltiptext">Corta o texto em peda√ßos de tamanho igual, com sobreposi√ß√£o opcional. R√°pido, mas pode quebrar senten√ßas.</span>
                                </label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="recursive" name="algorithm" value="recursive" class="radio-input">
                                <label for="recursive" class="radio-label tooltip">
                                    <span class="radio-title">üîÑ Recursivo</span>
                                    <span class="radio-description">Mant√©m estrutura sem√¢ntica</span>
                                    <span class="tooltiptext">Tenta dividir por par√°grafos, depois senten√ßas, etc. Mant√©m a estrutura sem√¢ntica do texto.</span>
                                </label>
                            </div>
                            <div class="radio-option">
                                <input type="radio" id="semantic" name="algorithm" value="semantic" class="radio-input">
                                <label for="semantic" class="radio-label tooltip">
                                    <span class="radio-title">üß† Sem√¢ntico</span>
                                    <span class="radio-description">Agrupa por similaridade de significado</span>
                                    <span class="tooltiptext">Agrupa senten√ßas por similaridade de significado. Cria chunks coesos tematicamente (simula√ß√£o).</span>
                                </label>
                            </div>
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">‚öôÔ∏è Ajuste os Par√¢metros</label>
                        <div id="params" class="space-y-4">
                            <!-- Par√¢metros ser√£o inseridos aqui pelo JS -->
                        </div>
                    </div>

                    <button id="chunkButton" class="btn btn-primary w-full">
                        üîç Visualizar Chunking
                    </button>
                </div>
            </div>

            <!-- √Årea de Resultados -->
            <div class="results-area">
                <div class="glass-card">
                    <div class="section-header">
                        <h2 class="section-title">üìä Visualiza√ß√£o do Processo</h2>
                    </div>
                    <div id="visualization" class="w-full h-10 bg-gray-200 rounded-lg mb-6 relative overflow-hidden">
                        <!-- SVG da anima√ß√£o ser√° inserido aqui -->
                    </div>

                    <div class="section-header">
                        <h2 class="section-title">üìù Chunks Gerados (<span id="chunkCount" class="badge badge-primary">0</span>)</h2>
                    </div>
                    <div id="output" class="space-y-4">
                        <div class="empty-state">
                            <p>üîç Os resultados aparecer√£o aqui ap√≥s processar o texto</p>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // --- ELEMENTOS DO DOM ---
        const inputText = document.getElementById('inputText');
        const algorithmSelector = document.getElementById('algorithmSelector');
        const paramsContainer = document.getElementById('params');
        const chunkButton = document.getElementById('chunkButton');
        const outputContainer = document.getElementById('output');
        const chunkCountSpan = document.getElementById('chunkCount');
        const visualizationContainer = document.getElementById('visualization');

        // --- ESTADO DA APLICA√á√ÉO ---
        let currentAlgorithm = 'fixed';

        // --- MODELO DE DADOS PARA PAR√ÇMETROS ---
        const ALGORITHM_PARAMS = {
            fixed: `
                <div class="param-group">
                    <label for="chunkSize" class="param-label">üìè Tamanho do Chunk: <span id="chunkSizeValue" class="param-value">100</span></label>
                    <input type="range" id="chunkSize" min="20" max="500" value="100" class="range-input">
                </div>
                <div class="param-group">
                    <label for="overlap" class="param-label">üîÑ Sobreposi√ß√£o: <span id="overlapValue" class="param-value">20</span></label>
                    <input type="range" id="overlap" min="0" max="100" value="20" class="range-input">
                </div>
            `,
            recursive: `
                <div class="param-group">
                    <label for="chunkSize" class="param-label">üìè Tamanho M√°x. do Chunk: <span id="chunkSizeValue" class="param-value">200</span></label>
                    <input type="range" id="chunkSize" min="50" max="1000" value="200" class="range-input">
                </div>
            `,
            semantic: `
                <div class="param-group">
                    <label for="threshold" class="param-label">üéØ Limiar de Similaridade: <span id="thresholdValue" class="param-value">0.3</span></label>
                    <input type="range" id="threshold" min="0.1" max="0.9" step="0.05" value="0.3" class="range-input">
                    <div class="param-hint">üí° Valores mais baixos criam chunks maiores. Valores mais altos criam mais chunks.</div>
                </div>
            `
        };

        // --- FUN√á√ïES DE CHUNKING ---

        /**
         * Algoritmo de Tamanho Fixo
         * @param {string} text - O texto de entrada
         * @param {number} chunkSize - O tamanho de cada chunk
         * @param {number} overlap - A sobreposi√ß√£o entre chunks
         * @returns {Array<Object>} - Array de objetos de chunk com texto e √≠ndices
         */
        function fixedSizeChunker(text, chunkSize, overlap) {
            if (!text) return [];
            const chunks = [];
            let i = 0;
            while (i < text.length) {
                const start = i;
                const end = i + chunkSize;
                chunks.push({ text: text.slice(start, end), start, end: Math.min(end, text.length) });
                i += chunkSize - overlap;
                if (i <= start) break; // Evita loop infinito se overlap >= chunkSize
            }
            return chunks;
        }

        /**
         * Algoritmo Recursivo
         * @param {string} text - O texto de entrada
         * @param {number} chunkSize - O tamanho m√°ximo de cada chunk
         * @returns {Array<Object>} - Array de objetos de chunk com texto e √≠ndices
         */
        function recursiveChunker(text, chunkSize) {
            if (!text) return [];
            const separators = ['\n\n', '\n', '. ', ' ', ''];
            
            function split(textToSplit, separators, originalOffset = 0) {
                const currentSeparator = separators[0];
                const nextSeparators = separators.slice(1);

                if (!currentSeparator) { // Chegou ao fim dos separadores, divide por caractere
                    const chunks = [];
                    for(let i = 0; i < textToSplit.length; i += chunkSize) {
                        const chunkText = textToSplit.slice(i, i + chunkSize);
                        chunks.push({
                            text: chunkText,
                            start: originalOffset + i,
                            end: originalOffset + i + chunkText.length
                        });
                    }
                    return chunks;
                }

                const splits = textToSplit.split(currentSeparator);
                const goodChunks = [];
                let currentChunkText = "";
                let currentChunkStart = originalOffset;

                for (let i = 0; i < splits.length; i++) {
                    const splitText = splits[i];
                    if (!splitText) continue;

                    const potentialChunk = currentChunkText + (currentChunkText ? currentSeparator : '') + splitText;

                    if (potentialChunk.length > chunkSize) {
                        if (currentChunkText) { // Salva o chunk atual se existir
                            goodChunks.push({
                                text: currentChunkText,
                                start: currentChunkStart,
                                end: currentChunkStart + currentChunkText.length
                            });
                        }
                        // O novo split √© muito grande, ent√£o o dividimos recursivamente
                        const subChunks = split(splitText, nextSeparators, originalOffset + textToSplit.indexOf(splitText));
                        goodChunks.push(...subChunks);
                        currentChunkText = "";
                    } else {
                        if (!currentChunkText) {
                            currentChunkStart = originalOffset + textToSplit.indexOf(splitText);
                        }
                        currentChunkText = potentialChunk;
                    }
                }

                if (currentChunkText) { // Adiciona o √∫ltimo chunk
                    goodChunks.push({
                        text: currentChunkText,
                        start: currentChunkStart,
                        end: currentChunkStart + currentChunkText.length
                    });
                }
                return goodChunks;
            }

            return split(text, separators);
        }

        /**
         * Simula√ß√£o de Algoritmo Sem√¢ntico
         * @param {string} text - O texto de entrada
         * @param {number} threshold - O limiar para criar uma nova divis√£o
         * @returns {Array<Object>} - Array de objetos de chunk com texto e √≠ndices
         */
        function semanticChunker(text, threshold) {
            if (!text) return [];
            // 1. Dividir em senten√ßas
            const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];
            if (sentences.length <= 1) return [{ text, start: 0, end: text.length }];

            // 2. Simular embeddings (hash simples das palavras)
            const embeddings = sentences.map(s => {
                const words = s.toLowerCase().match(/\b\w+\b/g) || [];
                let hash = 0;
                words.forEach(word => {
                    for (let i = 0; i < word.length; i++) {
                        hash = (hash << 5) - hash + word.charCodeAt(i);
                        hash |= 0; // Converte para 32bit integer
                    }
                });
                return hash / 1e10; // Normaliza para um valor pequeno
            });

            // 3. Calcular "dist√¢ncia" e encontrar pontos de quebra
            const breakpoints = [0];
            for (let i = 1; i < embeddings.length; i++) {
                const distance = Math.abs(embeddings[i] - embeddings[i - 1]);
                if (distance > threshold) {
                    breakpoints.push(i);
                }
            }

            // 4. Agrupar senten√ßas em chunks
            const chunks = [];
            let originalIndex = 0;
            for (let i = 0; i < breakpoints.length; i++) {
                const startIdx = breakpoints[i];
                const endIdx = (i + 1 < breakpoints.length) ? breakpoints[i + 1] : sentences.length;
                const chunkSentences = sentences.slice(startIdx, endIdx);
                if (chunkSentences.length > 0) {
                    const chunkText = chunkSentences.join(' ');
                    const start = text.indexOf(chunkSentences[0], originalIndex);
                    const end = start + chunkText.length;
                    chunks.push({ text: chunkText, start, end });
                    originalIndex = end;
                }
            }
            return chunks;
        }


        // --- L√ìGICA DA UI ---

        /**
         * Atualiza os par√¢metros exibidos com base no algoritmo selecionado
         */
        function updateParamsUI() {
            paramsContainer.innerHTML = ALGORITHM_PARAMS[currentAlgorithm];
            // Adiciona listeners para os novos inputs
            const inputs = paramsContainer.querySelectorAll('input[type="range"]');
            inputs.forEach(input => {
                const valueSpan = document.getElementById(`${input.id}Value`);
                if (valueSpan) {
                    valueSpan.textContent = input.value;
                    input.addEventListener('input', (e) => {
                        valueSpan.textContent = e.target.value;
                    });
                }
            });
        }

        /**
         * Exibe os chunks gerados na UI
         * @param {Array<Object>} chunks - O array de chunks a ser exibido
         * @param {Object} statistics - Estat√≠sticas opcionais do chunking
         */
        function displayChunks(chunks, statistics = null) {
            outputContainer.innerHTML = '';
            chunkCountSpan.textContent = chunks.length;
            if (chunks.length === 0) {
                outputContainer.innerHTML = '<div class="empty-state"><p>‚ùå Nenhum chunk foi gerado. Tente ajustar os par√¢metros ou o texto.</p></div>';
                return;
            }

            const colors = ['#3b82f6', '#10b981', '#ef4444', '#f97316', '#8b5cf6', '#ec4899'];
            chunks.forEach((chunk, index) => {
                const color = colors[index % colors.length];
                const chunkEl = document.createElement('div');
                chunkEl.className = 'chunk-item';
                chunkEl.style.setProperty('--chunk-color', color);
                chunkEl.style.animationDelay = `${index * 100}ms`;
                
                const tokensInfo = chunk.tokens ? ` | ${chunk.tokens} tokens` : '';
                const metadataInfo = chunk.metadata ? ` | ${JSON.stringify(chunk.metadata)}` : '';
                
                chunkEl.innerHTML = `
                    <div class="chunk-header">
                        <h3 class="chunk-title">üìÑ Chunk ${index + 1}</h3>
                        <div class="chunk-meta">
                            <span class="badge badge-secondary">√çndices: ${chunk.start}-${chunk.end}</span>
                            <span class="badge badge-info">${chunk.text.length} chars${tokensInfo}</span>
                        </div>
                    </div>
                    <div class="chunk-content">${chunk.text}</div>
                    ${metadataInfo ? `<div class="chunk-metadata">üîç Metadata: ${metadataInfo}</div>` : ''}
                `;
                
                chunkEl.addEventListener('mouseover', () => highlightChunkInViz(chunk, color));
                chunkEl.addEventListener('mouseout', () => clearHighlightInViz());

                outputContainer.appendChild(chunkEl);
            });
        }

        /**
         * Exibe estat√≠sticas do chunking
         * @param {Object} statistics - Estat√≠sticas do chunking
         * @param {number} executionTime - Tempo de execu√ß√£o em ms
         */
        function displayStatistics(statistics, executionTime) {
            if (!statistics) return;
            
            const statsEl = document.createElement('div');
            statsEl.className = 'stats-container';
            statsEl.innerHTML = `
                <div class="section-header">
                    <h3 class="section-title">üìä Estat√≠sticas do Chunking</h3>
                </div>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value">${statistics.total_chunks}</div>
                        <div class="stat-label">üìÑ Total de Chunks</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${Math.round(statistics.avg_chunk_size)}</div>
                        <div class="stat-label">üìè Tamanho M√©dio (chars)</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${Math.round(statistics.avg_tokens)}</div>
                        <div class="stat-label">üî§ Tokens M√©dios</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value">${executionTime}ms</div>
                        <div class="stat-label">‚è±Ô∏è Tempo de Execu√ß√£o</div>
                    </div>
                </div>
            `;
            outputContainer.appendChild(statsEl);
        }
        
        /**
         * Inicia a anima√ß√£o de visualiza√ß√£o
         * @param {Array<Object>} chunks - O array de chunks para visualizar
         */
        function runVisualization(chunks) {
            visualizationContainer.innerHTML = ''; // Limpa visualiza√ß√£o anterior
            const totalLength = inputText.value.length;
            if (totalLength === 0) return;

            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, "svg");
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.setAttribute('preserveAspectRatio', 'none');
            svg.setAttribute('viewBox', `0 0 ${totalLength} 40`);

            // Barra de fundo representando o texto inteiro
            const bgRect = document.createElementNS(svgNS, 'rect');
            bgRect.setAttribute('x', '0');
            bgRect.setAttribute('y', '0');
            bgRect.setAttribute('width', totalLength);
            bgRect.setAttribute('height', '40');
            bgRect.setAttribute('fill', '#e5e7eb');
            svg.appendChild(bgRect);

            // Destaque que segue o mouse
            const highlightRect = document.createElementNS(svgNS, 'rect');
            highlightRect.setAttribute('id', 'viz-highlight');
            highlightRect.setAttribute('y', '0');
            highlightRect.setAttribute('height', '40');
            highlightRect.setAttribute('fill', 'black');
            highlightRect.setAttribute('opacity', '0');
            svg.appendChild(highlightRect);

            visualizationContainer.appendChild(svg);
            
            // Linha de escaneamento
            const scanner = document.createElement('div');
            scanner.className = 'scanner-line';
            visualizationContainer.appendChild(scanner);
            
            // Desenha os chunks ap√≥s a anima√ß√£o do scanner
            setTimeout(() => {
                visualizationContainer.removeChild(scanner);
                const colors = ['#3b82f6', '#10b981', '#ef4444', '#f97316', '#8b5cf6', '#ec4899'];
                chunks.forEach((chunk, index) => {
                    const color = colors[index % colors.length];
                    const chunkRect = document.createElementNS(svgNS, 'rect');
                    chunkRect.setAttribute('x', chunk.start);
                    chunkRect.setAttribute('y', '0');
                    chunkRect.setAttribute('width', chunk.end - chunk.start);
                    chunkRect.setAttribute('height', '40');
                    chunkRect.setAttribute('fill', color);
                    chunkRect.setAttribute('opacity', '0.6');
                    chunkRect.style.transition = 'opacity 0.3s ease';
                    svg.appendChild(chunkRect);
                });
            }, 3000);
        }

        function highlightChunkInViz(chunk, color) {
            const highlightRect = document.getElementById('viz-highlight');
            if (highlightRect) {
                highlightRect.setAttribute('x', chunk.start);
                highlightRect.setAttribute('width', chunk.end - chunk.start);
                highlightRect.setAttribute('fill', color);
                highlightRect.setAttribute('opacity', '0.4');
            }
        }

        function clearHighlightInViz() {
            const highlightRect = document.getElementById('viz-highlight');
            if (highlightRect) {
                highlightRect.setAttribute('opacity', '0');
            }
        }


        /**
         * Fun√ß√£o principal que orquestra o processo de chunking
         */
        async function handleChunking() {
            const text = inputText.value.trim();
            if (!text) {
                alert('Por favor, insira algum texto para fazer chunking.');
                return;
            }

            try {
                // Preparar par√¢metros baseados no algoritmo atual
                let params = {};
                switch (currentAlgorithm) {
                    case 'fixed':
                        params = {
                            max_chunk_size: parseInt(document.getElementById('chunkSize').value, 10),
                            overlap_ratio: parseInt(document.getElementById('overlap').value, 10) / 100
                        };
                        break;
                    case 'recursive':
                        params = {
                            max_chunk_size: parseInt(document.getElementById('chunkSize').value, 10),
                            preserve_sentences: true,
                            preserve_paragraphs: true
                        };
                        break;
                    case 'semantic':
                        params = {
                            threshold: parseFloat(document.getElementById('threshold').value),
                            preserve_sentences: true
                        };
                        break;
                }

                // Preparar requisi√ß√£o para API
                const request = {
                    text: text,
                    strategy: currentAlgorithm,
                    ...params
                };

                // Fazer requisi√ß√£o para API de chunking
                const response = await fetch('/chunking/process', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(request)
                });

                if (!response.ok) {
                    throw new Error(`Erro na API: ${response.status}`);
                }

                const result = await response.json();
                
                // Converter formato da API para formato esperado pelo frontend
                const chunks = result.chunks.map((chunk, index) => ({
                    text: chunk.text,
                    start: chunk.start_pos,
                    end: chunk.end_pos,
                    tokens: chunk.token_count,
                    metadata: chunk.metadata
                }));

                runVisualization(chunks);
                // Atraso para exibir os chunks ap√≥s a anima√ß√£o
                setTimeout(() => {
                    displayChunks(chunks, result.statistics);
                    displayStatistics(result.statistics, result.execution_time_ms);
                }, 3000);
                
            } catch (error) {
                console.error('Erro no chunking:', error);
                // Fallback para chunking local em caso de erro
                let chunks = [];
                
                switch (currentAlgorithm) {
                    case 'fixed':
                        const fixedChunkSize = parseInt(document.getElementById('chunkSize').value, 10);
                        const overlap = parseInt(document.getElementById('overlap').value, 10);
                        chunks = fixedSizeChunker(text, fixedChunkSize, overlap);
                        break;
                    case 'recursive':
                        const recursiveChunkSize = parseInt(document.getElementById('chunkSize').value, 10);
                        chunks = recursiveChunker(text, recursiveChunkSize);
                        break;
                    case 'semantic':
                        const threshold = parseFloat(document.getElementById('threshold').value);
                        chunks = semanticChunker(text, threshold);
                        break;
                }

                runVisualization(chunks);
                setTimeout(() => {
                    displayChunks(chunks);
                }, 3000);
            }
        }

        // --- EVENT LISTENERS ---
        algorithmSelector.addEventListener('change', (e) => {
            currentAlgorithm = e.target.value;
            updateParamsUI();
        });

        chunkButton.addEventListener('click', handleChunking);

        // --- INICIALIZA√á√ÉO ---
        document.addEventListener('DOMContentLoaded', () => {
            updateParamsUI();
        });
    </script>
</body>
</html>
