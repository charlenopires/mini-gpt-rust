<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Demonstração Interativa de Chunking</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
        }
        .control-panel-bg {
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }
        .chunk-item {
            transition: all 0.5s ease-in-out;
            opacity: 0;
            transform: translateY(20px);
            animation: fadeIn 0.5s forwards;
        }
        @keyframes fadeIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        .scanner-line {
            position: absolute;
            top: 0;
            left: 0;
            width: 3px;
            height: 100%;
            background-color: #3b82f6;
            box-shadow: 0 0 10px #3b82f6;
            animation: scan 3s linear forwards;
        }
        @keyframes scan {
            from { transform: translateX(0%); }
            to { transform: translateX(calc(100% - 3px)); }
        }
        .chunk-highlight {
            position: absolute;
            top: 0;
            height: 100%;
            opacity: 0.3;
            transition: all 0.3s ease;
        }
        .tooltip {
            position: relative;
            display: inline-block;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 220px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -110px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.8rem;
            font-weight: 400;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">
    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-900">Demonstração Interativa de Chunking</h1>
            <p class="mt-2 text-lg text-gray-600">Veja como diferentes algoritmos dividem o texto em pedaços (chunks).</p>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- Painel de Controle -->
            <div class="lg:col-span-1 space-y-6">
                <div class="control-panel-bg p-6 rounded-2xl shadow-lg sticky top-8">
                    <h2 class="text-2xl font-semibold mb-4 text-gray-800">1. Insira seu Texto</h2>
                    <textarea id="inputText" class="w-full h-48 p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 transition" placeholder="Cole ou digite seu texto aqui...">O chunking é o processo de dividir textos longos em pedaços menores e semanticamente significativos, chamados de chunks. Esta é uma etapa crucial em pipelines de Processamento de Linguagem Natural, especialmente para aplicações de Geração Aumentada por Recuperação (RAG).

Existem várias estratégias para o chunking. A mais simples é a de tamanho fixo, que corta o texto em segmentos de um tamanho pré-definido. Uma abordagem mais sofisticada é a recursiva, que tenta dividir o texto por parágrafos, depois por sentenças, e assim por diante, para manter a coesão.

A estratégia mais avançada é o chunking semântico. Este método utiliza modelos de embedding para "entender" o significado do texto e faz as divisões onde ocorrem mudanças de tópico, garantindo que cada chunk seja tematicamente coeso. A escolha do método correto impacta diretamente a qualidade do contexto fornecido ao LLM.</textarea>

                    <h2 class="text-2xl font-semibold mt-6 mb-4 text-gray-800">2. Escolha o Algoritmo</h2>
                    <div id="algorithmSelector" class="space-y-2">
                        <div>
                            <input type="radio" id="fixed" name="algorithm" value="fixed" class="hidden peer" checked>
                            <label for="fixed" class="block w-full text-center p-3 border-2 border-gray-300 rounded-lg cursor-pointer peer-checked:border-blue-500 peer-checked:bg-blue-50 peer-checked:text-blue-700 font-medium transition tooltip">
                                Tamanho Fixo
                                <span class="tooltiptext">Corta o texto em pedaços de tamanho igual, com sobreposição opcional. Rápido, mas pode quebrar sentenças.</span>
                            </label>
                        </div>
                        <div>
                            <input type="radio" id="recursive" name="algorithm" value="recursive" class="hidden peer">
                            <label for="recursive" class="block w-full text-center p-3 border-2 border-gray-300 rounded-lg cursor-pointer peer-checked:border-blue-500 peer-checked:bg-blue-50 peer-checked:text-blue-700 font-medium transition tooltip">
                                Recursivo
                                <span class="tooltiptext">Tenta dividir por parágrafos, depois sentenças, etc. Mantém a estrutura semântica do texto.</span>
                            </label>
                        </div>
                        <div>
                            <input type="radio" id="semantic" name="algorithm" value="semantic" class="hidden peer">
                            <label for="semantic" class="block w-full text-center p-3 border-2 border-gray-300 rounded-lg cursor-pointer peer-checked:border-blue-500 peer-checked:bg-blue-50 peer-checked:text-blue-700 font-medium transition tooltip">
                                Semântico (Simulado)
                                <span class="tooltiptext">Agrupa sentenças por similaridade de significado. Cria chunks coesos tematicamente (simulação).</span>
                            </label>
                        </div>
                    </div>

                    <h2 class="text-2xl font-semibold mt-6 mb-4 text-gray-800">3. Ajuste os Parâmetros</h2>
                    <div id="params" class="space-y-4">
                        <!-- Parâmetros serão inseridos aqui pelo JS -->
                    </div>

                    <button id="chunkButton" class="w-full mt-6 bg-blue-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-700 active:bg-blue-800 transition-transform transform hover:scale-105 active:scale-100 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                        Visualizar Chunking
                    </button>
                </div>
            </div>

            <!-- Área de Resultados -->
            <div class="lg:col-span-2">
                <div class="bg-white p-6 rounded-2xl shadow-lg">
                    <h2 class="text-2xl font-semibold mb-4 text-gray-800">Visualização do Processo</h2>
                    <div id="visualization" class="w-full h-10 bg-gray-200 rounded-lg mb-6 relative overflow-hidden">
                        <!-- SVG da animação será inserido aqui -->
                    </div>

                    <h2 class="text-2xl font-semibold mb-4 text-gray-800">Chunks Gerados (<span id="chunkCount">0</span>)</h2>
                    <div id="output" class="space-y-4">
                        <p class="text-gray-500">Os resultados aparecerão aqui após clicar no botão.</p>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // --- ELEMENTOS DO DOM ---
        const inputText = document.getElementById('inputText');
        const algorithmSelector = document.getElementById('algorithmSelector');
        const paramsContainer = document.getElementById('params');
        const chunkButton = document.getElementById('chunkButton');
        const outputContainer = document.getElementById('output');
        const chunkCountSpan = document.getElementById('chunkCount');
        const visualizationContainer = document.getElementById('visualization');

        // --- ESTADO DA APLICAÇÃO ---
        let currentAlgorithm = 'fixed';

        // --- MODELO DE DADOS PARA PARÂMETROS ---
        const ALGORITHM_PARAMS = {
            fixed: `
                <div>
                    <label for="chunkSize" class="block font-medium text-gray-700">Tamanho do Chunk: <span id="chunkSizeValue">100</span></label>
                    <input type="range" id="chunkSize" min="20" max="500" value="100" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                </div>
                <div>
                    <label for="overlap" class="block font-medium text-gray-700">Sobreposição: <span id="overlapValue">20</span></label>
                    <input type="range" id="overlap" min="0" max="100" value="20" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                </div>
            `,
            recursive: `
                <div>
                    <label for="chunkSize" class="block font-medium text-gray-700">Tamanho Máx. do Chunk: <span id="chunkSizeValue">200</span></label>
                    <input type="range" id="chunkSize" min="50" max="1000" value="200" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                </div>
            `,
            semantic: `
                <div>
                    <label for="threshold" class="block font-medium text-gray-700">Limiar de Similaridade: <span id="thresholdValue">0.3</span></label>
                    <input type="range" id="threshold" min="0.1" max="0.9" step="0.05" value="0.3" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                </div>
                <p class="text-xs text-gray-500">Valores mais baixos criam chunks maiores. Valores mais altos criam mais chunks.</p>
            `
        };

        // --- FUNÇÕES DE CHUNKING ---

        /**
         * Algoritmo de Tamanho Fixo
         * @param {string} text - O texto de entrada
         * @param {number} chunkSize - O tamanho de cada chunk
         * @param {number} overlap - A sobreposição entre chunks
         * @returns {Array<Object>} - Array de objetos de chunk com texto e índices
         */
        function fixedSizeChunker(text, chunkSize, overlap) {
            if (!text) return [];
            const chunks = [];
            let i = 0;
            while (i < text.length) {
                const start = i;
                const end = i + chunkSize;
                chunks.push({ text: text.slice(start, end), start, end: Math.min(end, text.length) });
                i += chunkSize - overlap;
                if (i <= start) break; // Evita loop infinito se overlap >= chunkSize
            }
            return chunks;
        }

        /**
         * Algoritmo Recursivo
         * @param {string} text - O texto de entrada
         * @param {number} chunkSize - O tamanho máximo de cada chunk
         * @returns {Array<Object>} - Array de objetos de chunk com texto e índices
         */
        function recursiveChunker(text, chunkSize) {
            if (!text) return [];
            const separators = ['\n\n', '\n', '. ', ' ', ''];
            
            function split(textToSplit, separators, originalOffset = 0) {
                const currentSeparator = separators[0];
                const nextSeparators = separators.slice(1);

                if (!currentSeparator) { // Chegou ao fim dos separadores, divide por caractere
                    const chunks = [];
                    for(let i = 0; i < textToSplit.length; i += chunkSize) {
                        const chunkText = textToSplit.slice(i, i + chunkSize);
                        chunks.push({
                            text: chunkText,
                            start: originalOffset + i,
                            end: originalOffset + i + chunkText.length
                        });
                    }
                    return chunks;
                }

                const splits = textToSplit.split(currentSeparator);
                const goodChunks = [];
                let currentChunkText = "";
                let currentChunkStart = originalOffset;

                for (let i = 0; i < splits.length; i++) {
                    const splitText = splits[i];
                    if (!splitText) continue;

                    const potentialChunk = currentChunkText + (currentChunkText ? currentSeparator : '') + splitText;

                    if (potentialChunk.length > chunkSize) {
                        if (currentChunkText) { // Salva o chunk atual se existir
                            goodChunks.push({
                                text: currentChunkText,
                                start: currentChunkStart,
                                end: currentChunkStart + currentChunkText.length
                            });
                        }
                        // O novo split é muito grande, então o dividimos recursivamente
                        const subChunks = split(splitText, nextSeparators, originalOffset + textToSplit.indexOf(splitText));
                        goodChunks.push(...subChunks);
                        currentChunkText = "";
                    } else {
                        if (!currentChunkText) {
                            currentChunkStart = originalOffset + textToSplit.indexOf(splitText);
                        }
                        currentChunkText = potentialChunk;
                    }
                }

                if (currentChunkText) { // Adiciona o último chunk
                    goodChunks.push({
                        text: currentChunkText,
                        start: currentChunkStart,
                        end: currentChunkStart + currentChunkText.length
                    });
                }
                return goodChunks;
            }

            return split(text, separators);
        }

        /**
         * Simulação de Algoritmo Semântico
         * @param {string} text - O texto de entrada
         * @param {number} threshold - O limiar para criar uma nova divisão
         * @returns {Array<Object>} - Array de objetos de chunk com texto e índices
         */
        function semanticChunker(text, threshold) {
            if (!text) return [];
            // 1. Dividir em sentenças
            const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];
            if (sentences.length <= 1) return [{ text, start: 0, end: text.length }];

            // 2. Simular embeddings (hash simples das palavras)
            const embeddings = sentences.map(s => {
                const words = s.toLowerCase().match(/\b\w+\b/g) || [];
                let hash = 0;
                words.forEach(word => {
                    for (let i = 0; i < word.length; i++) {
                        hash = (hash << 5) - hash + word.charCodeAt(i);
                        hash |= 0; // Converte para 32bit integer
                    }
                });
                return hash / 1e10; // Normaliza para um valor pequeno
            });

            // 3. Calcular "distância" e encontrar pontos de quebra
            const breakpoints = [0];
            for (let i = 1; i < embeddings.length; i++) {
                const distance = Math.abs(embeddings[i] - embeddings[i - 1]);
                if (distance > threshold) {
                    breakpoints.push(i);
                }
            }

            // 4. Agrupar sentenças em chunks
            const chunks = [];
            let originalIndex = 0;
            for (let i = 0; i < breakpoints.length; i++) {
                const startIdx = breakpoints[i];
                const endIdx = (i + 1 < breakpoints.length) ? breakpoints[i + 1] : sentences.length;
                const chunkSentences = sentences.slice(startIdx, endIdx);
                if (chunkSentences.length > 0) {
                    const chunkText = chunkSentences.join(' ');
                    const start = text.indexOf(chunkSentences[0], originalIndex);
                    const end = start + chunkText.length;
                    chunks.push({ text: chunkText, start, end });
                    originalIndex = end;
                }
            }
            return chunks;
        }


        // --- LÓGICA DA UI ---

        /**
         * Atualiza os parâmetros exibidos com base no algoritmo selecionado
         */
        function updateParamsUI() {
            paramsContainer.innerHTML = ALGORITHM_PARAMS[currentAlgorithm];
            // Adiciona listeners para os novos inputs
            const inputs = paramsContainer.querySelectorAll('input[type="range"]');
            inputs.forEach(input => {
                const valueSpan = document.getElementById(`${input.id}Value`);
                if (valueSpan) {
                    valueSpan.textContent = input.value;
                    input.addEventListener('input', (e) => {
                        valueSpan.textContent = e.target.value;
                    });
                }
            });
        }

        /**
         * Exibe os chunks gerados na UI
         * @param {Array<Object>} chunks - O array de chunks a ser exibido
         */
        function displayChunks(chunks) {
            outputContainer.innerHTML = '';
            chunkCountSpan.textContent = chunks.length;
            if (chunks.length === 0) {
                outputContainer.innerHTML = '<p class="text-gray-500">Nenhum chunk foi gerado. Tente ajustar os parâmetros ou o texto.</p>';
                return;
            }

            const colors = ['#3b82f6', '#10b981', '#ef4444', '#f97316', '#8b5cf6', '#ec4899'];
            chunks.forEach((chunk, index) => {
                const color = colors[index % colors.length];
                const chunkEl = document.createElement('div');
                chunkEl.className = 'chunk-item border-l-4 p-4 rounded-r-lg bg-gray-50';
                chunkEl.style.borderColor = color;
                chunkEl.style.animationDelay = `${index * 100}ms`;
                
                chunkEl.innerHTML = `
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="font-bold text-lg" style="color: ${color};">Chunk ${index + 1}</h3>
                        <span class="text-sm font-mono text-gray-500">Índices: ${chunk.start}-${chunk.end} (${chunk.text.length} chars)</span>
                    </div>
                    <p class="text-gray-700 whitespace-pre-wrap">${chunk.text}</p>
                `;
                
                chunkEl.addEventListener('mouseover', () => highlightChunkInViz(chunk, color));
                chunkEl.addEventListener('mouseout', () => clearHighlightInViz());

                outputContainer.appendChild(chunkEl);
            });
        }
        
        /**
         * Inicia a animação de visualização
         * @param {Array<Object>} chunks - O array de chunks para visualizar
         */
        function runVisualization(chunks) {
            visualizationContainer.innerHTML = ''; // Limpa visualização anterior
            const totalLength = inputText.value.length;
            if (totalLength === 0) return;

            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, "svg");
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.setAttribute('preserveAspectRatio', 'none');
            svg.setAttribute('viewBox', `0 0 ${totalLength} 40`);

            // Barra de fundo representando o texto inteiro
            const bgRect = document.createElementNS(svgNS, 'rect');
            bgRect.setAttribute('x', '0');
            bgRect.setAttribute('y', '0');
            bgRect.setAttribute('width', totalLength);
            bgRect.setAttribute('height', '40');
            bgRect.setAttribute('fill', '#e5e7eb');
            svg.appendChild(bgRect);

            // Destaque que segue o mouse
            const highlightRect = document.createElementNS(svgNS, 'rect');
            highlightRect.setAttribute('id', 'viz-highlight');
            highlightRect.setAttribute('y', '0');
            highlightRect.setAttribute('height', '40');
            highlightRect.setAttribute('fill', 'black');
            highlightRect.setAttribute('opacity', '0');
            svg.appendChild(highlightRect);

            visualizationContainer.appendChild(svg);
            
            // Linha de escaneamento
            const scanner = document.createElement('div');
            scanner.className = 'scanner-line';
            visualizationContainer.appendChild(scanner);
            
            // Desenha os chunks após a animação do scanner
            setTimeout(() => {
                visualizationContainer.removeChild(scanner);
                const colors = ['#3b82f6', '#10b981', '#ef4444', '#f97316', '#8b5cf6', '#ec4899'];
                chunks.forEach((chunk, index) => {
                    const color = colors[index % colors.length];
                    const chunkRect = document.createElementNS(svgNS, 'rect');
                    chunkRect.setAttribute('x', chunk.start);
                    chunkRect.setAttribute('y', '0');
                    chunkRect.setAttribute('width', chunk.end - chunk.start);
                    chunkRect.setAttribute('height', '40');
                    chunkRect.setAttribute('fill', color);
                    chunkRect.setAttribute('opacity', '0.6');
                    chunkRect.style.transition = 'opacity 0.3s ease';
                    svg.appendChild(chunkRect);
                });
            }, 3000);
        }

        function highlightChunkInViz(chunk, color) {
            const highlightRect = document.getElementById('viz-highlight');
            if (highlightRect) {
                highlightRect.setAttribute('x', chunk.start);
                highlightRect.setAttribute('width', chunk.end - chunk.start);
                highlightRect.setAttribute('fill', color);
                highlightRect.setAttribute('opacity', '0.4');
            }
        }

        function clearHighlightInViz() {
            const highlightRect = document.getElementById('viz-highlight');
            if (highlightRect) {
                highlightRect.setAttribute('opacity', '0');
            }
        }


        /**
         * Função principal que orquestra o processo de chunking
         */
        function handleChunking() {
            const text = inputText.value;
            let chunks = [];
            
            // Coleta os parâmetros com base no algoritmo atual
            switch (currentAlgorithm) {
                case 'fixed':
                    const fixedChunkSize = parseInt(document.getElementById('chunkSize').value, 10);
                    const overlap = parseInt(document.getElementById('overlap').value, 10);
                    chunks = fixedSizeChunker(text, fixedChunkSize, overlap);
                    break;
                case 'recursive':
                    const recursiveChunkSize = parseInt(document.getElementById('chunkSize').value, 10);
                    chunks = recursiveChunker(text, recursiveChunkSize);
                    break;
                case 'semantic':
                    const threshold = parseFloat(document.getElementById('threshold').value);
                    chunks = semanticChunker(text, threshold);
                    break;
            }

            runVisualization(chunks);
            // Atraso para exibir os chunks após a animação
            setTimeout(() => {
                displayChunks(chunks);
            }, 3000);
        }

        // --- EVENT LISTENERS ---
        algorithmSelector.addEventListener('change', (e) => {
            currentAlgorithm = e.target.value;
            updateParamsUI();
        });

        chunkButton.addEventListener('click', handleChunking);

        // --- INICIALIZAÇÃO ---
        document.addEventListener('DOMContentLoaded', () => {
            updateParamsUI();
        });
    </script>
</body>
</html>
