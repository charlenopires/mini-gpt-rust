<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Residual Connections - Mini GPT Rust</title>
    <link rel="stylesheet" href="css/design-system.css">
    <style>
        .residual-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .architecture-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 30px 0;
        }
        
        .architecture-card {
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 25px;
            transition: all 0.3s ease;
        }
        
        .architecture-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }
        
        .architecture-title {
            font-size: 1.3em;
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 15px;
            text-align: center;
        }
        
        .network-diagram {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            margin: 20px 0;
            min-height: 400px;
        }
        
        .layer-block {
            width: 120px;
            height: 60px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            background: white;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .layer-block.input {
            background: #e3f2fd;
            border-color: #2196f3;
            color: #1976d2;
        }
        
        .layer-block.hidden {
            background: #f3e5f5;
            border-color: #9c27b0;
            color: #7b1fa2;
        }
        
        .layer-block.output {
            background: #e8f5e8;
            border-color: #4caf50;
            color: #388e3c;
        }
        
        .layer-block.active {
            animation: pulse 1.5s infinite;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .connection-arrow {
            width: 3px;
            height: 30px;
            background: var(--primary-color);
            position: relative;
            transition: all 0.3s ease;
        }
        
        .connection-arrow::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: -4px;
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 10px solid var(--primary-color);
        }
        
        .connection-arrow.active {
            background: #4caf50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        
        .connection-arrow.active::after {
            border-top-color: #4caf50;
        }
        
        .residual-connection {
            position: absolute;
            right: -60px;
            top: 50%;
            width: 120px;
            height: 3px;
            background: #ff9800;
            border-radius: 2px;
            transform: translateY(-50%);
            transition: all 0.3s ease;
        }
        
        .residual-connection::before {
            content: '';
            position: absolute;
            right: -8px;
            top: -4px;
            width: 0;
            height: 0;
            border-left: 10px solid #ff9800;
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
        }
        
        .residual-connection.active {
            background: #ff5722;
            box-shadow: 0 0 10px rgba(255, 87, 34, 0.5);
        }
        
        .residual-connection.active::before {
            border-left-color: #ff5722;
        }
        
        .addition-symbol {
            position: absolute;
            right: -30px;
            top: 50%;
            transform: translateY(-50%);
            width: 30px;
            height: 30px;
            border: 2px solid #ff9800;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            font-weight: bold;
            color: #ff9800;
            font-size: 18px;
            transition: all 0.3s ease;
        }
        
        .addition-symbol.active {
            border-color: #ff5722;
            color: #ff5722;
            box-shadow: 0 0 10px rgba(255, 87, 34, 0.3);
        }
        
        .gradient-flow {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 25px;
            margin: 30px 0;
        }
        
        .gradient-visualization {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 20px 0;
            padding: 20px;
            background: white;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }
        
        .gradient-bar {
            width: 150px;
            height: 20px;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            background: #f5f5f5;
        }
        
        .gradient-fill {
            height: 100%;
            border-radius: 10px;
            transition: all 0.5s ease;
            position: relative;
        }
        
        .gradient-fill.strong {
            background: linear-gradient(90deg, #4caf50, #8bc34a);
        }
        
        .gradient-fill.weak {
            background: linear-gradient(90deg, #ffeb3b, #ffc107);
        }
        
        .gradient-fill.vanishing {
            background: linear-gradient(90deg, #f44336, #e57373);
        }
        
        .gradient-label {
            text-align: center;
            font-weight: 600;
            margin-top: 5px;
            font-size: 0.9em;
        }
        
        .control-panel {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .control-group {
            margin: 15px 0;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .slider {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: var(--border-color);
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
        }
        
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            border: none;
        }
        
        .value-display {
            min-width: 60px;
            text-align: center;
            font-weight: 600;
            color: var(--primary-color);
        }
        
        .play-button {
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px 5px;
        }
        
        .play-button:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }
        
        .math-section {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .math-formula {
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Times New Roman', serif;
            text-align: center;
            font-size: 1.1em;
        }
        
        .benefits-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .benefit-card {
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            transition: all 0.3s ease;
        }
        
        .benefit-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }
        
        .benefit-icon {
            font-size: 2em;
            margin-bottom: 10px;
        }
        
        .benefit-title {
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 10px;
        }
        
        .comparison-chart {
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            height: 300px;
        }
        
        .problem-demonstration {
            background: #fff3e0;
            border: 1px solid #ff9800;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .problem-title {
            color: #f57c00;
            font-weight: 600;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .solution-demonstration {
            background: #e8f5e8;
            border: 1px solid #4caf50;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .solution-title {
            color: #388e3c;
            font-weight: 600;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .highlight {
            background: linear-gradient(120deg, var(--primary-color)20, transparent);
            padding: 2px 4px;
            border-radius: 4px;
        }
        
        .layer-depth-indicator {
            position: absolute;
            left: -40px;
            top: 50%;
            transform: translateY(-50%);
            background: var(--primary-color);
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8em;
            font-weight: 600;
        }
        
        @media (max-width: 768px) {
            .architecture-comparison {
                grid-template-columns: 1fr;
            }
            
            .residual-connection {
                display: none;
            }
            
            .addition-symbol {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="residual-container">
        <header class="hero-section">
            <h1>🔗 Residual Connections</h1>
            <p class="hero-description">
                Descubra como as conexões residuais revolucionaram o treinamento de redes neurais profundas, 
                resolvendo o problema do gradiente que desaparece e permitindo arquiteturas muito mais profundas.
            </p>
        </header>

        <section class="concept-explanation">
            <h2>🔍 O que são Residual Connections?</h2>
            <p>
                As <strong>Residual Connections</strong> (ou skip connections) são conexões diretas que permitem 
                que a informação "pule" uma ou mais camadas da rede neural. Elas foram introduzidas no ResNet 
                e são fundamentais nos Transformers modernos.
            </p>
            
            <div class="math-formula">
                <strong>Fórmula Básica:</strong><br>
                y = F(x) + x<br>
                <small>onde F(x) é a transformação da camada e x é a entrada original</small>
            </div>
        </section>

        <section class="architecture-comparison">
            <div class="architecture-card">
                <div class="architecture-title">❌ Sem Residual Connections</div>
                <div class="network-diagram" id="traditional-network">
                    <!-- Será preenchido dinamicamente -->
                </div>
                <div class="problem-demonstration">
                    <div class="problem-title">
                        ⚠️ Problemas
                    </div>
                    <ul>
                        <li>Gradientes desaparecem em redes profundas</li>
                        <li>Dificuldade de treinar mais de 10-20 camadas</li>
                        <li>Degradação da performance com profundidade</li>
                    </ul>
                </div>
            </div>
            
            <div class="architecture-card">
                <div class="architecture-title">✅ Com Residual Connections</div>
                <div class="network-diagram" id="residual-network">
                    <!-- Será preenchido dinamicamente -->
                </div>
                <div class="solution-demonstration">
                    <div class="solution-title">
                        ✨ Benefícios
                    </div>
                    <ul>
                        <li>Gradientes fluem diretamente através das conexões</li>
                        <li>Permite redes com centenas de camadas</li>
                        <li>Melhora significativa na convergência</li>
                    </ul>
                </div>
            </div>
        </section>

        <section class="control-panel">
            <h3>Simulação de Treinamento</h3>
            
            <div class="control-group">
                <label>Número de Camadas: <span id="layers-value">6</span></label>
                <div class="slider-container">
                    <input type="range" id="layers-slider" class="slider" min="3" max="12" step="1" value="6">
                    <div class="value-display" id="layers-display">6</div>
                </div>
            </div>
            
            <div class="control-group">
                <label>Taxa de Aprendizado: <span id="lr-value">0.001</span></label>
                <div class="slider-container">
                    <input type="range" id="lr-slider" class="slider" min="0.0001" max="0.01" step="0.0001" value="0.001">
                    <div class="value-display" id="lr-display">0.001</div>
                </div>
            </div>
            
            <button class="play-button" onclick="animateForwardPass()">▶️ Forward Pass</button>
            <button class="play-button" onclick="animateBackwardPass()">⬅️ Backward Pass</button>
            <button class="play-button" onclick="compareArchitectures()">⚖️ Comparar</button>
            <button class="play-button" onclick="resetAnimation()">🔄 Reset</button>
        </section>

        <section class="gradient-flow">
            <h2>📈 Fluxo de Gradientes</h2>
            
            <div class="gradient-visualization">
                <div>
                    <div class="gradient-bar">
                        <div class="gradient-fill strong" id="gradient-layer-1" style="width: 100%;"></div>
                    </div>
                    <div class="gradient-label">Camada 1</div>
                </div>
                
                <div>
                    <div class="gradient-bar">
                        <div class="gradient-fill strong" id="gradient-layer-2" style="width: 90%;"></div>
                    </div>
                    <div class="gradient-label">Camada 2</div>
                </div>
                
                <div>
                    <div class="gradient-bar">
                        <div class="gradient-fill weak" id="gradient-layer-3" style="width: 70%;"></div>
                    </div>
                    <div class="gradient-label">Camada 3</div>
                </div>
                
                <div>
                    <div class="gradient-bar">
                        <div class="gradient-fill weak" id="gradient-layer-4" style="width: 40%;"></div>
                    </div>
                    <div class="gradient-label">Camada 4</div>
                </div>
                
                <div>
                    <div class="gradient-bar">
                        <div class="gradient-fill vanishing" id="gradient-layer-5" style="width: 15%;"></div>
                    </div>
                    <div class="gradient-label">Camada 5</div>
                </div>
                
                <div>
                    <div class="gradient-bar">
                        <div class="gradient-fill vanishing" id="gradient-layer-6" style="width: 5%;"></div>
                    </div>
                    <div class="gradient-label">Camada 6</div>
                </div>
            </div>
            
            <p>
                <strong>Sem Residual Connections:</strong> Os gradientes diminuem exponencialmente 
                conforme se propagam para trás através das camadas, tornando o treinamento das 
                primeiras camadas extremamente lento ou impossível.
            </p>
        </section>

        <section class="benefits-grid">
            <div class="benefit-card">
                <div class="benefit-icon">🚀</div>
                <div class="benefit-title">Treinamento Mais Rápido</div>
                <p>As conexões residuais permitem que os gradientes fluam diretamente, acelerando significativamente a convergência.</p>
            </div>
            
            <div class="benefit-card">
                <div class="benefit-icon">🏗️</div>
                <div class="benefit-title">Redes Mais Profundas</div>
                <p>Possibilita a construção de arquiteturas com centenas de camadas sem degradação da performance.</p>
            </div>
            
            <div class="benefit-card">
                <div class="benefit-icon">🎯</div>
                <div class="benefit-title">Melhor Precisão</div>
                <p>Redes residuais consistentemente alcançam maior precisão em tarefas de classificação e outras.</p>
            </div>
            
            <div class="benefit-card">
                <div class="benefit-icon">🔧</div>
                <div class="benefit-title">Facilita Otimização</div>
                <p>Torna a superfície de perda mais suave, facilitando o trabalho dos otimizadores.</p>
            </div>
        </section>

        <section class="mathematical-details">
            <h2>🔢 Detalhes Matemáticos</h2>
            
            <div class="math-section">
                <h3>Transformação Residual</h3>
                <div class="math-formula">
                    <strong>Bloco Residual:</strong><br>
                    y = F(x, {Wᵢ}) + x<br>
                    <small>F(x, {Wᵢ}) representa a transformação aprendida</small>
                </div>
                
                <h3>Gradiente através de Residual Connections</h3>
                <div class="math-formula">
                    ∂L/∂x = ∂L/∂y × (∂F/∂x + 1)<br>
                    <small>O termo "+1" garante que o gradiente nunca desaparece completamente</small>
                </div>
                
                <h3>No Transformer</h3>
                <div class="math-formula">
                    <strong>Attention Block:</strong> x + Attention(LayerNorm(x))<br>
                    <strong>FFN Block:</strong> x + FFN(LayerNorm(x))<br>
                    <small>Cada sub-camada tem sua própria conexão residual</small>
                </div>
            </div>
        </section>

        <section class="comparison-chart">
            <h2>📊 Comparação de Performance</h2>
            <canvas id="performance-chart" width="800" height="250"></canvas>
        </section>

        <section class="implementation-details">
            <h2>💻 Implementação em Rust</h2>
            
            <div class="math-section">
                <h3>Estrutura Básica</h3>
                <div class="math-formula" style="text-align: left; font-family: 'Courier New', monospace;">
                    <strong>struct ResidualBlock {</strong><br>
                    &nbsp;&nbsp;&nbsp;&nbsp;layer: Linear,<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;activation: ReLU,<br>
                    }<br><br>
                    
                    <strong>impl ResidualBlock {</strong><br>
                    &nbsp;&nbsp;&nbsp;&nbsp;fn forward(&self, x: &Tensor) -> Tensor {<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let residual = x.clone();<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let output = self.activation.forward(<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.layer.forward(x)<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;);<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output + residual  // Conexão residual<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                    }
                </div>
            </div>
        </section>
    </div>

    <script>
        let currentLayers = 6;
        let currentLR = 0.001;
        let animationRunning = false;
        
        // Elementos DOM
        const layersSlider = document.getElementById('layers-slider');
        const lrSlider = document.getElementById('lr-slider');
        const performanceChart = document.getElementById('performance-chart');
        const ctx = performanceChart.getContext('2d');
        
        // Event listeners
        layersSlider.addEventListener('input', (e) => {
            currentLayers = parseInt(e.target.value);
            document.getElementById('layers-display').textContent = currentLayers;
            updateNetworks();
            updateGradientVisualization();
        });
        
        lrSlider.addEventListener('input', (e) => {
            currentLR = parseFloat(e.target.value);
            document.getElementById('lr-display').textContent = currentLR.toFixed(4);
        });
        
        function updateNetworks() {
            updateTraditionalNetwork();
            updateResidualNetwork();
        }
        
        function updateTraditionalNetwork() {
            const container = document.getElementById('traditional-network');
            container.innerHTML = '';
            
            for (let i = 0; i < currentLayers; i++) {
                // Camada
                const layer = document.createElement('div');
                layer.className = 'layer-block';
                layer.style.position = 'relative';
                
                if (i === 0) {
                    layer.classList.add('input');
                    layer.textContent = 'Input';
                } else if (i === currentLayers - 1) {
                    layer.classList.add('output');
                    layer.textContent = 'Output';
                } else {
                    layer.classList.add('hidden');
                    layer.textContent = `Layer ${i}`;
                }
                
                // Indicador de profundidade
                const depthIndicator = document.createElement('div');
                depthIndicator.className = 'layer-depth-indicator';
                depthIndicator.textContent = i + 1;
                layer.appendChild(depthIndicator);
                
                container.appendChild(layer);
                
                // Seta (exceto para a última camada)
                if (i < currentLayers - 1) {
                    const arrow = document.createElement('div');
                    arrow.className = 'connection-arrow';
                    container.appendChild(arrow);
                }
            }
        }
        
        function updateResidualNetwork() {
            const container = document.getElementById('residual-network');
            container.innerHTML = '';
            
            for (let i = 0; i < currentLayers; i++) {
                // Camada
                const layer = document.createElement('div');
                layer.className = 'layer-block';
                layer.style.position = 'relative';
                
                if (i === 0) {
                    layer.classList.add('input');
                    layer.textContent = 'Input';
                } else if (i === currentLayers - 1) {
                    layer.classList.add('output');
                    layer.textContent = 'Output';
                } else {
                    layer.classList.add('hidden');
                    layer.textContent = `Layer ${i}`;
                }
                
                // Indicador de profundidade
                const depthIndicator = document.createElement('div');
                depthIndicator.className = 'layer-depth-indicator';
                depthIndicator.textContent = i + 1;
                layer.appendChild(depthIndicator);
                
                // Conexão residual (para camadas intermediárias)
                if (i > 0 && i < currentLayers - 1) {
                    const residualConn = document.createElement('div');
                    residualConn.className = 'residual-connection';
                    layer.appendChild(residualConn);
                    
                    const addSymbol = document.createElement('div');
                    addSymbol.className = 'addition-symbol';
                    addSymbol.textContent = '+';
                    layer.appendChild(addSymbol);
                }
                
                container.appendChild(layer);
                
                // Seta (exceto para a última camada)
                if (i < currentLayers - 1) {
                    const arrow = document.createElement('div');
                    arrow.className = 'connection-arrow';
                    container.appendChild(arrow);
                }
            }
        }
        
        function updateGradientVisualization() {
            for (let i = 1; i <= 6; i++) {
                const gradientFill = document.getElementById(`gradient-layer-${i}`);
                if (gradientFill) {
                    // Simula degradação do gradiente
                    const degradation = Math.pow(0.7, i - 1);
                    const width = Math.max(5, degradation * 100);
                    gradientFill.style.width = `${width}%`;
                    
                    // Atualiza classe baseada na força do gradiente
                    gradientFill.className = 'gradient-fill';
                    if (width > 70) {
                        gradientFill.classList.add('strong');
                    } else if (width > 30) {
                        gradientFill.classList.add('weak');
                    } else {
                        gradientFill.classList.add('vanishing');
                    }
                }
            }
        }
        
        function animateForwardPass() {
            if (animationRunning) return;
            animationRunning = true;
            
            const layers = document.querySelectorAll('.layer-block');
            const arrows = document.querySelectorAll('.connection-arrow');
            
            // Reset
            layers.forEach(layer => layer.classList.remove('active'));
            arrows.forEach(arrow => arrow.classList.remove('active'));
            
            let currentStep = 0;
            
            function animateStep() {
                if (currentStep < layers.length) {
                    layers[currentStep].classList.add('active');
                    
                    if (currentStep < arrows.length) {
                        arrows[currentStep].classList.add('active');
                    }
                    
                    currentStep++;
                    setTimeout(animateStep, 500);
                } else {
                    animationRunning = false;
                }
            }
            
            animateStep();
        }
        
        function animateBackwardPass() {
            if (animationRunning) return;
            animationRunning = true;
            
            const residualConns = document.querySelectorAll('.residual-connection');
            const addSymbols = document.querySelectorAll('.addition-symbol');
            
            // Reset
            residualConns.forEach(conn => conn.classList.remove('active'));
            addSymbols.forEach(symbol => symbol.classList.remove('active'));
            
            let currentStep = 0;
            
            function animateStep() {
                if (currentStep < residualConns.length) {
                    residualConns[currentStep].classList.add('active');
                    addSymbols[currentStep].classList.add('active');
                    
                    currentStep++;
                    setTimeout(animateStep, 300);
                } else {
                    animationRunning = false;
                }
            }
            
            animateStep();
        }
        
        function compareArchitectures() {
            drawPerformanceChart();
        }
        
        function resetAnimation() {
            const activeElements = document.querySelectorAll('.active');
            activeElements.forEach(element => element.classList.remove('active'));
            animationRunning = false;
        }
        
        function drawPerformanceChart() {
            ctx.clearRect(0, 0, performanceChart.width, performanceChart.height);
            
            const margin = 40;
            const chartWidth = performanceChart.width - 2 * margin;
            const chartHeight = performanceChart.height - 2 * margin;
            
            // Eixos
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(margin, margin + chartHeight);
            ctx.lineTo(margin + chartWidth, margin + chartHeight);
            ctx.moveTo(margin, margin);
            ctx.lineTo(margin, margin + chartHeight);
            ctx.stroke();
            
            // Labels dos eixos
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Número de Camadas', margin + chartWidth/2, margin + chartHeight + 30);
            
            ctx.save();
            ctx.translate(15, margin + chartHeight/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('Precisão (%)', 0, 0);
            ctx.restore();
            
            // Dados simulados
            const layers = [2, 4, 6, 8, 10, 12, 16, 20, 24, 28];
            const traditionalAccuracy = [85, 87, 88, 87, 85, 82, 78, 72, 65, 58];
            const residualAccuracy = [85, 89, 91, 93, 94, 95, 96, 96.5, 97, 97.2];
            
            // Linha tradicional
            ctx.strokeStyle = '#f44336';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            for (let i = 0; i < layers.length; i++) {
                const x = margin + (layers[i] / 30) * chartWidth;
                const y = margin + chartHeight - (traditionalAccuracy[i] / 100) * chartHeight;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // Linha residual
            ctx.strokeStyle = '#4caf50';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            for (let i = 0; i < layers.length; i++) {
                const x = margin + (layers[i] / 30) * chartWidth;
                const y = margin + chartHeight - (residualAccuracy[i] / 100) * chartHeight;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // Legenda
            ctx.fillStyle = '#f44336';
            ctx.fillRect(margin + chartWidth - 200, margin + 20, 20, 3);
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Sem Residual Connections', margin + chartWidth - 175, margin + 25);
            
            ctx.fillStyle = '#4caf50';
            ctx.fillRect(margin + chartWidth - 200, margin + 40, 20, 3);
            ctx.fillStyle = '#333';
            ctx.fillText('Com Residual Connections', margin + chartWidth - 175, margin + 45);
        }
        
        // Inicialização
        updateNetworks();
        updateGradientVisualization();
        drawPerformanceChart();
    </script>
</body>
</html>