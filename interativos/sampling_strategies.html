<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Estrat√©gias de Amostragem - Mini GPT Rust</title>
    <link rel="stylesheet" href="css/design-system.css">
    <style>
        .sampling-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .strategy-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .strategy-card {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            transition: all 0.3s ease;
        }
        
        .strategy-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.1);
        }
        
        .strategy-card.active {
            border-color: var(--primary-color);
            background: linear-gradient(135deg, var(--primary-color)10, transparent);
        }
        
        .control-panel {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .control-group {
            margin: 15px 0;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .slider {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: var(--border-color);
            outline: none;
            -webkit-appearance: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
        }
        
        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-color);
            cursor: pointer;
            border: none;
        }
        
        .value-display {
            min-width: 60px;
            text-align: center;
            font-weight: 600;
            color: var(--primary-color);
        }
        
        .probability-chart {
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            height: 300px;
        }
        
        .token-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 10px;
            margin: 20px 0;
        }
        
        .token-item {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .token-item.selected {
            background: var(--primary-color);
            color: white;
            transform: scale(1.05);
        }
        
        .token-item.filtered {
            opacity: 0.3;
            background: var(--muted-color);
        }
        
        .token-word {
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        .token-prob {
            font-size: 0.9em;
            opacity: 0.8;
        }
        
        .generation-demo {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .generated-text {
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            min-height: 100px;
            font-family: 'Courier New', monospace;
            line-height: 1.6;
        }
        
        .generate-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .generate-btn:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .comparison-table th,
        .comparison-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }
        
        .comparison-table th {
            background: var(--primary-color);
            color: white;
            font-weight: 600;
        }
        
        .comparison-table tr:hover {
            background: var(--muted-color);
        }
        
        .math-formula {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Times New Roman', serif;
            text-align: center;
            font-size: 1.1em;
        }
        
        .highlight {
            background: linear-gradient(120deg, var(--primary-color)20, transparent);
            padding: 2px 4px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="sampling-container">
        <header class="hero-section">
            <h1>üé≤ Estrat√©gias de Amostragem</h1>
            <p class="hero-description">
                Descubra como diferentes estrat√©gias de amostragem controlam a criatividade e qualidade da gera√ß√£o de texto em modelos de linguagem.
            </p>
        </header>

        <section class="concept-explanation">
            <h2>üß† O que √© Amostragem?</h2>
            <p>
                Quando um modelo de linguagem gera texto, ele produz uma distribui√ß√£o de probabilidades sobre todos os tokens poss√≠veis. 
                A <strong>amostragem</strong> √© o processo de escolher qual token ser√° gerado com base nessas probabilidades.
            </p>
            
            <div class="math-formula">
                <strong>Distribui√ß√£o de Probabilidades:</strong><br>
                P(token‚ÇÅ, token‚ÇÇ, ..., token‚Çô) onde Œ£ P(token·µ¢) = 1
            </div>
        </section>

        <section class="strategies-overview">
            <h2>üéØ Estrat√©gias de Amostragem</h2>
            
            <div class="strategy-grid">
                <div class="strategy-card" data-strategy="greedy">
                    <h3>üéØ Greedy Sampling</h3>
                    <p>Sempre escolhe o token com maior probabilidade. Determin√≠stico mas pode ser repetitivo.</p>
                    <div class="highlight">Mais Conservador</div>
                </div>
                
                <div class="strategy-card" data-strategy="temperature">
                    <h3>üå°Ô∏è Temperature Sampling</h3>
                    <p>Controla a "temperatura" da distribui√ß√£o. Valores baixos = mais conservador, altos = mais criativo.</p>
                    <div class="highlight">Controle de Criatividade</div>
                </div>
                
                <div class="strategy-card" data-strategy="top-k">
                    <h3>üîù Top-K Sampling</h3>
                    <p>Considera apenas os K tokens mais prov√°veis, redistribuindo suas probabilidades.</p>
                    <div class="highlight">Filtragem por Ranking</div>
                </div>
                
                <div class="strategy-card" data-strategy="top-p">
                    <h3>üìä Top-P (Nucleus) Sampling</h3>
                    <p>Considera tokens at√© que a soma das probabilidades atinja P. Adaptativo ao contexto.</p>
                    <div class="highlight">Mais Inteligente</div>
                </div>
            </div>
        </section>

        <section class="interactive-demo">
            <h2>üéÆ Demonstra√ß√£o Interativa</h2>
            
            <div class="control-panel">
                <h3>Configura√ß√µes de Amostragem</h3>
                
                <div class="control-group">
                    <label>Estrat√©gia:</label>
                    <select id="strategy-select">
                        <option value="greedy">Greedy Sampling</option>
                        <option value="temperature">Temperature Sampling</option>
                        <option value="top-k">Top-K Sampling</option>
                        <option value="top-p">Top-P (Nucleus) Sampling</option>
                    </select>
                </div>
                
                <div class="control-group" id="temperature-control">
                    <label>Temperature: <span id="temp-value">1.0</span></label>
                    <div class="slider-container">
                        <input type="range" id="temperature-slider" class="slider" min="0.1" max="2.0" step="0.1" value="1.0">
                        <div class="value-display" id="temp-display">1.0</div>
                    </div>
                </div>
                
                <div class="control-group" id="top-k-control" style="display: none;">
                    <label>Top-K: <span id="k-value">50</span></label>
                    <div class="slider-container">
                        <input type="range" id="top-k-slider" class="slider" min="1" max="100" step="1" value="50">
                        <div class="value-display" id="k-display">50</div>
                    </div>
                </div>
                
                <div class="control-group" id="top-p-control" style="display: none;">
                    <label>Top-P: <span id="p-value">0.9</span></label>
                    <div class="slider-container">
                        <input type="range" id="top-p-slider" class="slider" min="0.1" max="1.0" step="0.05" value="0.9">
                        <div class="value-display" id="p-display">0.9</div>
                    </div>
                </div>
            </div>
            
            <div class="probability-chart">
                <canvas id="prob-chart" width="800" height="250"></canvas>
            </div>
            
            <div class="token-list" id="token-list">
                <!-- Tokens ser√£o gerados dinamicamente -->
            </div>
        </section>

        <section class="generation-demo">
            <h2>üìù Gera√ß√£o de Texto</h2>
            <p>Veja como diferentes estrat√©gias afetam a gera√ß√£o de texto:</p>
            
            <div class="control-group">
                <label>Prompt inicial:</label>
                <input type="text" id="prompt-input" value="Era uma vez" style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 4px;">
            </div>
            
            <button class="generate-btn" onclick="generateText()">üé≤ Gerar Texto</button>
            
            <div class="generated-text" id="generated-text">
                Clique em "Gerar Texto" para ver o resultado...
            </div>
        </section>

        <section class="comparison">
            <h2>‚öñÔ∏è Compara√ß√£o de Estrat√©gias</h2>
            
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Estrat√©gia</th>
                        <th>Determinismo</th>
                        <th>Criatividade</th>
                        <th>Qualidade</th>
                        <th>Uso Recomendado</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Greedy</strong></td>
                        <td>Alto</td>
                        <td>Baixa</td>
                        <td>Consistente</td>
                        <td>Tarefas factuais, tradu√ß√£o</td>
                    </tr>
                    <tr>
                        <td><strong>Temperature</strong></td>
                        <td>Vari√°vel</td>
                        <td>Control√°vel</td>
                        <td>Vari√°vel</td>
                        <td>Escrita criativa, di√°logos</td>
                    </tr>
                    <tr>
                        <td><strong>Top-K</strong></td>
                        <td>M√©dio</td>
                        <td>M√©dia</td>
                        <td>Boa</td>
                        <td>Gera√ß√£o geral, chatbots</td>
                    </tr>
                    <tr>
                        <td><strong>Top-P</strong></td>
                        <td>Baixo</td>
                        <td>Alta</td>
                        <td>Muito Boa</td>
                        <td>Escrita criativa, storytelling</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section class="mathematical-details">
            <h2>üî¢ Detalhes Matem√°ticos</h2>
            
            <h3>Temperature Sampling</h3>
            <div class="math-formula">
                P'(token·µ¢) = exp(logits_i / T) / Œ£‚±º exp(logits_j / T)<br>
                <small>onde T √© a temperatura</small>
            </div>
            
            <h3>Top-K Sampling</h3>
            <div class="math-formula">
                P'(token·µ¢) = P(token·µ¢) / Œ£‚±º‚ààtop_k P(token‚±º)<br>
                <small>para os K tokens mais prov√°veis</small>
            </div>
            
            <h3>Top-P (Nucleus) Sampling</h3>
            <div class="math-formula">
                Nucleus = {token·µ¢ : Œ£‚±º‚â§·µ¢ P(token‚±º) ‚â§ p}<br>
                <small>onde tokens s√£o ordenados por probabilidade</small>
            </div>
        </section>
    </div>

    <script>
        // Dados simulados de tokens e probabilidades
        const sampleTokens = [
            { word: "o", prob: 0.25 },
            { word: "uma", prob: 0.20 },
            { word: "a", prob: 0.15 },
            { word: "um", prob: 0.12 },
            { word: "que", prob: 0.08 },
            { word: "de", prob: 0.06 },
            { word: "para", prob: 0.04 },
            { word: "com", prob: 0.03 },
            { word: "em", prob: 0.02 },
            { word: "por", prob: 0.02 },
            { word: "se", prob: 0.015 },
            { word: "do", prob: 0.01 },
            { word: "da", prob: 0.005 }
        ];
        
        let currentStrategy = 'greedy';
        let temperature = 1.0;
        let topK = 50;
        let topP = 0.9;
        
        // Elementos DOM
        const strategySelect = document.getElementById('strategy-select');
        const temperatureSlider = document.getElementById('temperature-slider');
        const topKSlider = document.getElementById('top-k-slider');
        const topPSlider = document.getElementById('top-p-slider');
        const canvas = document.getElementById('prob-chart');
        const ctx = canvas.getContext('2d');
        
        // Event listeners
        strategySelect.addEventListener('change', (e) => {
            currentStrategy = e.target.value;
            updateControls();
            updateVisualization();
        });
        
        temperatureSlider.addEventListener('input', (e) => {
            temperature = parseFloat(e.target.value);
            document.getElementById('temp-display').textContent = temperature.toFixed(1);
            updateVisualization();
        });
        
        topKSlider.addEventListener('input', (e) => {
            topK = parseInt(e.target.value);
            document.getElementById('k-display').textContent = topK;
            updateVisualization();
        });
        
        topPSlider.addEventListener('input', (e) => {
            topP = parseFloat(e.target.value);
            document.getElementById('p-display').textContent = topP.toFixed(2);
            updateVisualization();
        });
        
        function updateControls() {
            // Esconder todos os controles
            document.getElementById('temperature-control').style.display = 'none';
            document.getElementById('top-k-control').style.display = 'none';
            document.getElementById('top-p-control').style.display = 'none';
            
            // Mostrar controles relevantes
            switch(currentStrategy) {
                case 'temperature':
                    document.getElementById('temperature-control').style.display = 'block';
                    break;
                case 'top-k':
                    document.getElementById('top-k-control').style.display = 'block';
                    break;
                case 'top-p':
                    document.getElementById('top-p-control').style.display = 'block';
                    break;
            }
            
            // Atualizar cards ativos
            document.querySelectorAll('.strategy-card').forEach(card => {
                card.classList.remove('active');
                if (card.dataset.strategy === currentStrategy) {
                    card.classList.add('active');
                }
            });
        }
        
        function applySampling(tokens, strategy) {
            let processedTokens = [...tokens];
            
            switch(strategy) {
                case 'greedy':
                    // Apenas o token mais prov√°vel
                    const maxProb = Math.max(...processedTokens.map(t => t.prob));
                    processedTokens = processedTokens.map(t => ({
                        ...t,
                        prob: t.prob === maxProb ? 1.0 : 0.0,
                        filtered: t.prob !== maxProb
                    }));
                    break;
                    
                case 'temperature':
                    // Aplicar temperature scaling
                    const logits = processedTokens.map(t => Math.log(t.prob));
                    const scaledLogits = logits.map(l => l / temperature);
                    const expScaled = scaledLogits.map(l => Math.exp(l));
                    const sumExp = expScaled.reduce((a, b) => a + b, 0);
                    
                    processedTokens = processedTokens.map((t, i) => ({
                        ...t,
                        prob: expScaled[i] / sumExp,
                        filtered: false
                    }));
                    break;
                    
                case 'top-k':
                    // Manter apenas top-k tokens
                    processedTokens.sort((a, b) => b.prob - a.prob);
                    const topKTokens = processedTokens.slice(0, Math.min(topK, processedTokens.length));
                    const sumTopK = topKTokens.reduce((sum, t) => sum + t.prob, 0);
                    
                    processedTokens = processedTokens.map((t, i) => ({
                        ...t,
                        prob: i < topK ? t.prob / sumTopK : 0,
                        filtered: i >= topK
                    }));
                    break;
                    
                case 'top-p':
                    // Nucleus sampling
                    processedTokens.sort((a, b) => b.prob - a.prob);
                    let cumSum = 0;
                    let nucleusSize = 0;
                    
                    for (let i = 0; i < processedTokens.length; i++) {
                        cumSum += processedTokens[i].prob;
                        nucleusSize++;
                        if (cumSum >= topP) break;
                    }
                    
                    const nucleusSum = processedTokens.slice(0, nucleusSize).reduce((sum, t) => sum + t.prob, 0);
                    
                    processedTokens = processedTokens.map((t, i) => ({
                        ...t,
                        prob: i < nucleusSize ? t.prob / nucleusSum : 0,
                        filtered: i >= nucleusSize
                    }));
                    break;
            }
            
            return processedTokens;
        }
        
        function updateVisualization() {
            const processedTokens = applySampling(sampleTokens, currentStrategy);
            
            // Atualizar gr√°fico
            drawProbabilityChart(processedTokens);
            
            // Atualizar lista de tokens
            updateTokenList(processedTokens);
        }
        
        function drawProbabilityChart(tokens) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const margin = 40;
            const chartWidth = canvas.width - 2 * margin;
            const chartHeight = canvas.height - 2 * margin;
            const barWidth = chartWidth / tokens.length;
            
            // Encontrar probabilidade m√°xima para escala
            const maxProb = Math.max(...tokens.map(t => t.prob));
            
            // Desenhar barras
            tokens.forEach((token, i) => {
                const barHeight = (token.prob / maxProb) * chartHeight;
                const x = margin + i * barWidth;
                const y = margin + chartHeight - barHeight;
                
                // Cor da barra
                if (token.filtered) {
                    ctx.fillStyle = '#e0e0e0';
                } else if (token.prob === maxProb && currentStrategy === 'greedy') {
                    ctx.fillStyle = '#ff6b6b';
                } else {
                    ctx.fillStyle = '#4ecdc4';
                }
                
                ctx.fillRect(x + 2, y, barWidth - 4, barHeight);
                
                // Label do token
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(token.word, x + barWidth/2, canvas.height - 10);
                
                // Valor da probabilidade
                ctx.fillStyle = '#666';
                ctx.font = '10px Arial';
                ctx.fillText(token.prob.toFixed(3), x + barWidth/2, y - 5);
            });
            
            // Eixos
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(margin, margin);
            ctx.lineTo(margin, margin + chartHeight);
            ctx.lineTo(margin + chartWidth, margin + chartHeight);
            ctx.stroke();
            
            // Labels dos eixos
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Tokens', canvas.width/2, canvas.height - 5);
            
            ctx.save();
            ctx.translate(15, canvas.height/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('Probabilidade', 0, 0);
            ctx.restore();
        }
        
        function updateTokenList(tokens) {
            const tokenList = document.getElementById('token-list');
            tokenList.innerHTML = '';
            
            tokens.forEach(token => {
                const tokenDiv = document.createElement('div');
                tokenDiv.className = 'token-item';
                if (token.filtered) tokenDiv.classList.add('filtered');
                if (token.prob > 0 && currentStrategy === 'greedy' && token.prob === 1.0) {
                    tokenDiv.classList.add('selected');
                }
                
                tokenDiv.innerHTML = `
                    <div class="token-word">${token.word}</div>
                    <div class="token-prob">${(token.prob * 100).toFixed(1)}%</div>
                `;
                
                tokenList.appendChild(tokenDiv);
            });
        }
        
        function generateText() {
            const prompt = document.getElementById('prompt-input').value;
            const generatedDiv = document.getElementById('generated-text');
            
            // Simula√ß√£o simples de gera√ß√£o de texto
            const continuations = {
                'greedy': [' um reino distante, vivia um rei muito s√°bio que governava com justi√ßa e bondade.'],
                'temperature': temperature < 0.5 ? 
                    [' um reino pr√≥spero, havia um castelo magn√≠fico onde residia uma princesa corajosa.'] :
                    [' uma dimens√£o paralela, existiam criaturas fant√°sticas que dan√ßavam sob a luz das estrelas roxas.'],
                'top-k': [' uma floresta encantada, os animais falantes se reuniam para contar hist√≥rias antigas.'],
                'top-p': [' um mundo onde a magia e a tecnologia coexistiam, um jovem inventor descobriu um segredo extraordin√°rio.']
            };
            
            const continuation = continuations[currentStrategy] || [' uma hist√≥ria interessante...'];
            generatedDiv.textContent = prompt + continuation[0];
        }
        
        // Inicializa√ß√£o
        updateControls();
        updateVisualization();
        
        // Adicionar interatividade aos cards de estrat√©gia
        document.querySelectorAll('.strategy-card').forEach(card => {
            card.addEventListener('click', () => {
                const strategy = card.dataset.strategy;
                strategySelect.value = strategy;
                currentStrategy = strategy;
                updateControls();
                updateVisualization();
            });
        });
    </script>
</body>
</html>