<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tokeniza√ß√£o - Mini-GPT Rust</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .token-item {
            display: inline-block;
            margin: 2px;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            position: relative;
        }
        .token-word {
            background-color: #dbeafe;
            color: #1e40af;
            border: 1px solid #93c5fd;
        }
        .token-subword {
            background-color: #fef3c7;
            color: #92400e;
            border: 1px solid #fcd34d;
        }
        .token-special {
            background-color: #fee2e2;
            color: #991b1b;
            border: 1px solid #fca5a5;
        }
        .token-punctuation {
            background-color: #f3e8ff;
            color: #7c3aed;
            border: 1px solid #c4b5fd;
        }
        .token-item:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        .scanner-line {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: #ef4444;
            z-index: 10;
            transition: left 0.5s ease;
        }
        .token-highlight {
            background-color: #fef08a !important;
            border-color: #eab308 !important;
            transform: scale(1.1);
        }
        .tooltip {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background-color: #1f2937;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 20;
        }
        .tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border: 4px solid transparent;
            border-top-color: #1f2937;
        }
        .token-item:hover .tooltip {
            opacity: 1;
        }
        .algorithm-option {
            transition: all 0.3s ease;
        }
        .algorithm-option:hover {
            background-color: #f3f4f6;
        }
        .algorithm-option.selected {
            background-color: #dbeafe;
            border-color: #3b82f6;
        }
        .gradient-bg {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <!-- Header -->
    <header class="gradient-bg text-white py-8">
        <div class="container mx-auto px-6">
            <div class="flex items-center justify-between">
                <div>
                    <h1 class="text-3xl font-bold mb-2">üî§ Tokeniza√ß√£o</h1>
                    <p class="text-lg opacity-90">Como o texto √© convertido em tokens process√°veis</p>
                </div>
                <a href="/" class="bg-white/20 hover:bg-white/30 px-4 py-2 rounded-lg transition-colors">
                    ‚Üê Voltar ao √çndice
                </a>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="container mx-auto px-6 py-8">
        <!-- Control Panel -->
        <section class="bg-white rounded-lg shadow-lg p-6 mb-8">
            <h2 class="text-2xl font-bold text-gray-800 mb-6">üéÆ Painel de Controle</h2>
            
            <!-- Text Input -->
            <div class="mb-6">
                <label for="input-text" class="block text-sm font-medium text-gray-700 mb-2">
                    Texto para Tokenizar:
                </label>
                <textarea 
                    id="input-text" 
                    class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                    rows="4"
                    placeholder="Digite ou cole o texto que voc√™ quer tokenizar..."
                >Ol√° mundo! Como voc√™ est√° hoje? Espero que esteja bem. üòä</textarea>
            </div>

            <!-- Algorithm Selection -->
            <div class="mb-6">
                <label class="block text-sm font-medium text-gray-700 mb-3">
                    Algoritmo de Tokeniza√ß√£o:
                </label>
                <div class="grid md:grid-cols-3 gap-4">
                    <div class="algorithm-option selected border-2 border-gray-200 rounded-lg p-4 cursor-pointer" data-algorithm="word">
                        <div class="flex items-center mb-2">
                            <div class="w-3 h-3 bg-blue-500 rounded-full mr-2"></div>
                            <h3 class="font-semibold text-gray-800">Por Palavras</h3>
                        </div>
                        <p class="text-sm text-gray-600">Divide o texto em palavras completas</p>
                        <div class="tooltip">Simples e intuitivo, mas vocabul√°rio limitado</div>
                    </div>
                    <div class="algorithm-option border-2 border-gray-200 rounded-lg p-4 cursor-pointer" data-algorithm="subword">
                        <div class="flex items-center mb-2">
                            <div class="w-3 h-3 bg-yellow-500 rounded-full mr-2"></div>
                            <h3 class="font-semibold text-gray-800">Subpalavras (BPE)</h3>
                        </div>
                        <p class="text-sm text-gray-600">Divide em subunidades menores</p>
                        <div class="tooltip">Usado em modelos modernos como GPT</div>
                    </div>
                    <div class="algorithm-option border-2 border-gray-200 rounded-lg p-4 cursor-pointer" data-algorithm="character">
                        <div class="flex items-center mb-2">
                            <div class="w-3 h-3 bg-purple-500 rounded-full mr-2"></div>
                            <h3 class="font-semibold text-gray-800">Por Caracteres</h3>
                        </div>
                        <p class="text-sm text-gray-600">Cada caractere √© um token</p>
                        <div class="tooltip">Vocabul√°rio m√≠nimo, mas sequ√™ncias longas</div>
                    </div>
                </div>
            </div>

            <!-- Parameters -->
            <div class="mb-6" id="parameters-section">
                <h3 class="text-lg font-semibold text-gray-800 mb-3">‚öôÔ∏è Par√¢metros</h3>
                <div class="grid md:grid-cols-2 gap-4" id="parameters-container">
                    <!-- Par√¢metros ser√£o inseridos dinamicamente -->
                </div>
            </div>

            <!-- Action Button -->
            <button 
                id="tokenize-btn" 
                class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold py-3 px-6 rounded-lg transition-colors"
            >
                üöÄ Visualizar Tokeniza√ß√£o
            </button>
        </section>

        <!-- Results Section -->
        <section class="bg-white rounded-lg shadow-lg p-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-6">üìä Resultado da Tokeniza√ß√£o</h2>
            
            <!-- Visualization Area -->
            <div class="mb-8">
                <h3 class="text-lg font-semibold text-gray-700 mb-4">üé¨ Processo de Tokeniza√ß√£o</h3>
                <div class="bg-gray-50 rounded-lg p-6 relative" id="visualization-area">
                    <div class="text-gray-500 text-center py-8">
                        Clique em "Visualizar Tokeniza√ß√£o" para ver o processo em a√ß√£o
                    </div>
                </div>
            </div>

            <!-- Tokens Display -->
            <div class="mb-8">
                <h3 class="text-lg font-semibold text-gray-700 mb-4">üî§ Tokens Gerados</h3>
                <div class="bg-gray-50 rounded-lg p-6" id="tokens-display">
                    <div class="text-gray-500 text-center py-4">
                        Os tokens aparecer√£o aqui ap√≥s a tokeniza√ß√£o
                    </div>
                </div>
            </div>

            <!-- Statistics -->
            <div>
                <h3 class="text-lg font-semibold text-gray-700 mb-4">üìà Estat√≠sticas</h3>
                <div class="grid md:grid-cols-4 gap-4" id="stats-container">
                    <div class="bg-blue-50 rounded-lg p-4 text-center">
                        <div class="text-2xl font-bold text-blue-600" id="total-tokens">-</div>
                        <div class="text-sm text-blue-800">Total de Tokens</div>
                    </div>
                    <div class="bg-green-50 rounded-lg p-4 text-center">
                        <div class="text-2xl font-bold text-green-600" id="unique-tokens">-</div>
                        <div class="text-sm text-green-800">Tokens √önicos</div>
                    </div>
                    <div class="bg-yellow-50 rounded-lg p-4 text-center">
                        <div class="text-2xl font-bold text-yellow-600" id="avg-length">-</div>
                        <div class="text-sm text-yellow-800">Comprimento M√©dio</div>
                    </div>
                    <div class="bg-purple-50 rounded-lg p-4 text-center">
                        <div class="text-2xl font-bold text-purple-600" id="compression-ratio">-</div>
                        <div class="text-sm text-purple-800">Taxa de Compress√£o</div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Educational Content -->
        <section class="bg-white rounded-lg shadow-lg p-6 mt-8">
            <h2 class="text-2xl font-bold text-gray-800 mb-6">üìö Conceitos Fundamentais</h2>
            
            <div class="grid md:grid-cols-2 gap-8">
                <div>
                    <h3 class="text-xl font-semibold text-gray-800 mb-4">ü§î Por que Tokenizar?</h3>
                    <ul class="space-y-2 text-gray-600">
                        <li class="flex items-start">
                            <span class="text-blue-500 mr-2">‚Ä¢</span>
                            <span>Modelos de IA processam n√∫meros, n√£o texto diretamente</span>
                        </li>
                        <li class="flex items-start">
                            <span class="text-blue-500 mr-2">‚Ä¢</span>
                            <span>Tokens s√£o unidades b√°sicas de processamento</span>
                        </li>
                        <li class="flex items-start">
                            <span class="text-blue-500 mr-2">‚Ä¢</span>
                            <span>Cada token √© mapeado para um n√∫mero √∫nico (ID)</span>
                        </li>
                        <li class="flex items-start">
                            <span class="text-blue-500 mr-2">‚Ä¢</span>
                            <span>Permite processamento eficiente em lotes</span>
                        </li>
                    </ul>
                </div>
                
                <div>
                    <h3 class="text-xl font-semibold text-gray-800 mb-4">‚öñÔ∏è Trade-offs dos Algoritmos</h3>
                    <div class="space-y-4">
                        <div class="border-l-4 border-blue-500 pl-4">
                            <h4 class="font-semibold text-blue-700">Por Palavras</h4>
                            <p class="text-sm text-gray-600">‚úÖ Simples ‚ùå Vocabul√°rio limitado</p>
                        </div>
                        <div class="border-l-4 border-yellow-500 pl-4">
                            <h4 class="font-semibold text-yellow-700">Subpalavras (BPE)</h4>
                            <p class="text-sm text-gray-600">‚úÖ Flex√≠vel ‚úÖ Vocabul√°rio eficiente</p>
                        </div>
                        <div class="border-l-4 border-purple-500 pl-4">
                            <h4 class="font-semibold text-purple-700">Por Caracteres</h4>
                            <p class="text-sm text-gray-600">‚úÖ Sem OOV ‚ùå Sequ√™ncias longas</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <script>
        // Elementos DOM
        const inputText = document.getElementById('input-text');
        const tokenizeBtn = document.getElementById('tokenize-btn');
        const visualizationArea = document.getElementById('visualization-area');
        const tokensDisplay = document.getElementById('tokens-display');
        const parametersContainer = document.getElementById('parameters-container');
        const algorithmOptions = document.querySelectorAll('.algorithm-option');
        
        // Estado da aplica√ß√£o
        let currentAlgorithm = 'word';
        let isTokenizing = false;
        
        // Par√¢metros para cada algoritmo
        const ALGORITHM_PARAMS = {
            word: {
                case_sensitive: { label: 'Sens√≠vel a mai√∫sculas', type: 'checkbox', default: false },
                remove_punctuation: { label: 'Remover pontua√ß√£o', type: 'checkbox', default: false }
            },
            subword: {
                vocab_size: { label: 'Tamanho do vocabul√°rio', type: 'range', min: 1000, max: 50000, default: 10000 },
                merge_operations: { label: 'Opera√ß√µes de merge', type: 'range', min: 100, max: 5000, default: 1000 }
            },
            character: {
                include_spaces: { label: 'Incluir espa√ßos', type: 'checkbox', default: true },
                include_punctuation: { label: 'Incluir pontua√ß√£o', type: 'checkbox', default: true }
            }
        };
        
        // Tokenizadores
        function wordTokenizer(text, params) {
            let processedText = text;
            
            if (!params.case_sensitive) {
                processedText = processedText.toLowerCase();
            }
            
            if (params.remove_punctuation) {
                processedText = processedText.replace(/[^\w\s]/g, '');
            }
            
            const tokens = processedText.split(/\s+/).filter(token => token.length > 0);
            
            return tokens.map((token, index) => ({
                text: token,
                type: 'word',
                id: index,
                start: text.indexOf(token),
                end: text.indexOf(token) + token.length
            }));
        }
        
        function subwordTokenizer(text, params) {
            // Simula√ß√£o simplificada do BPE
            const tokens = [];
            let currentPos = 0;
            
            // Primeiro, divide em palavras
            const words = text.split(/\s+/);
            
            words.forEach((word, wordIndex) => {
                if (word.length === 0) return;
                
                // Simula BPE dividindo palavras longas
                if (word.length > 6) {
                    // Divide em subpalavras
                    const subwords = [];
                    let remaining = word;
                    
                    while (remaining.length > 0) {
                        if (remaining.length <= 3) {
                            subwords.push(remaining);
                            break;
                        }
                        
                        const subwordLength = Math.min(4, remaining.length);
                        subwords.push(remaining.substring(0, subwordLength));
                        remaining = remaining.substring(subwordLength);
                    }
                    
                    subwords.forEach((subword, subIndex) => {
                        tokens.push({
                            text: subword + (subIndex < subwords.length - 1 ? '##' : ''),
                            type: 'subword',
                            id: tokens.length,
                            start: currentPos,
                            end: currentPos + subword.length
                        });
                        currentPos += subword.length;
                    });
                } else {
                    tokens.push({
                        text: word,
                        type: 'word',
                        id: tokens.length,
                        start: currentPos,
                        end: currentPos + word.length
                    });
                    currentPos += word.length;
                }
                
                // Adiciona espa√ßo se n√£o for a √∫ltima palavra
                if (wordIndex < words.length - 1) {
                    currentPos += 1;
                }
            });
            
            return tokens;
        }
        
        function characterTokenizer(text, params) {
            const tokens = [];
            
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                
                if (!params.include_spaces && char === ' ') continue;
                if (!params.include_punctuation && /[^\w\s]/.test(char)) continue;
                
                let type = 'character';
                if (/\s/.test(char)) type = 'space';
                else if (/[^\w\s]/.test(char)) type = 'punctuation';
                
                tokens.push({
                    text: char === ' ' ? '‚ê£' : char,
                    type: type,
                    id: tokens.length,
                    start: i,
                    end: i + 1
                });
            }
            
            return tokens;
        }
        
        // Atualiza par√¢metros baseado no algoritmo selecionado
        function updateParameters() {
            const params = ALGORITHM_PARAMS[currentAlgorithm];
            parametersContainer.innerHTML = '';
            
            Object.entries(params).forEach(([key, config]) => {
                const div = document.createElement('div');
                
                if (config.type === 'checkbox') {
                    div.innerHTML = `
                        <label class="flex items-center space-x-2">
                            <input type="checkbox" id="param-${key}" ${config.default ? 'checked' : ''} class="rounded">
                            <span class="text-sm font-medium text-gray-700">${config.label}</span>
                        </label>
                    `;
                } else if (config.type === 'range') {
                    div.innerHTML = `
                        <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">${config.label}</label>
                            <input type="range" id="param-${key}" min="${config.min}" max="${config.max}" value="${config.default}" class="w-full">
                            <div class="text-xs text-gray-500 mt-1">Valor: <span id="param-${key}-value">${config.default}</span></div>
                        </div>
                    `;
                    
                    // Adiciona listener para atualizar o valor exibido
                    setTimeout(() => {
                        const slider = document.getElementById(`param-${key}`);
                        const valueDisplay = document.getElementById(`param-${key}-value`);
                        slider.addEventListener('input', () => {
                            valueDisplay.textContent = slider.value;
                        });
                    }, 0);
                }
                
                parametersContainer.appendChild(div);
            });
        }
        
        // Coleta par√¢metros atuais
        function getCurrentParams() {
            const params = {};
            const paramConfigs = ALGORITHM_PARAMS[currentAlgorithm];
            
            Object.keys(paramConfigs).forEach(key => {
                const element = document.getElementById(`param-${key}`);
                if (element) {
                    if (element.type === 'checkbox') {
                        params[key] = element.checked;
                    } else {
                        params[key] = parseFloat(element.value);
                    }
                }
            });
            
            return params;
        }
        
        // Executa tokeniza√ß√£o
        function performTokenization() {
            const text = inputText.value.trim();
            if (!text) {
                alert('Por favor, insira algum texto para tokenizar.');
                return;
            }
            
            const params = getCurrentParams();
            let tokens = [];
            
            switch (currentAlgorithm) {
                case 'word':
                    tokens = wordTokenizer(text, params);
                    break;
                case 'subword':
                    tokens = subwordTokenizer(text, params);
                    break;
                case 'character':
                    tokens = characterTokenizer(text, params);
                    break;
            }
            
            displayTokens(tokens);
            updateStatistics(tokens, text);
            runVisualization(text, tokens);
        }
        
        // Exibe tokens
        function displayTokens(tokens) {
            tokensDisplay.innerHTML = '';
            
            tokens.forEach((token, index) => {
                const tokenElement = document.createElement('span');
                tokenElement.className = `token-item token-${token.type}`;
                tokenElement.textContent = token.text;
                
                const tooltip = document.createElement('div');
                tooltip.className = 'tooltip';
                tooltip.textContent = `ID: ${token.id} | Tipo: ${token.type} | Posi√ß√£o: ${token.start}-${token.end}`;
                tokenElement.appendChild(tooltip);
                
                tokensDisplay.appendChild(tokenElement);
            });
        }
        
        // Atualiza estat√≠sticas
        function updateStatistics(tokens, originalText) {
            const totalTokens = tokens.length;
            const uniqueTokens = new Set(tokens.map(t => t.text)).size;
            const avgLength = tokens.reduce((sum, t) => sum + t.text.length, 0) / totalTokens;
            const compressionRatio = (originalText.length / totalTokens).toFixed(1);
            
            document.getElementById('total-tokens').textContent = totalTokens;
            document.getElementById('unique-tokens').textContent = uniqueTokens;
            document.getElementById('avg-length').textContent = avgLength.toFixed(1);
            document.getElementById('compression-ratio').textContent = compressionRatio + 'x';
        }
        
        // Visualiza√ß√£o animada
        function runVisualization(text, tokens) {
            visualizationArea.innerHTML = `
                <div class="relative">
                    <div class="text-lg leading-relaxed" id="text-display">${text}</div>
                    <div class="scanner-line" id="scanner"></div>
                </div>
                <div class="mt-4 text-sm text-gray-600">
                    <span id="current-token-info">Preparando para tokenizar...</span>
                </div>
            `;
            
            const scanner = document.getElementById('scanner');
            const tokenInfo = document.getElementById('current-token-info');
            
            let currentTokenIndex = 0;
            
            function animateToken() {
                if (currentTokenIndex >= tokens.length) {
                    tokenInfo.textContent = 'Tokeniza√ß√£o conclu√≠da!';
                    scanner.style.display = 'none';
                    return;
                }
                
                const token = tokens[currentTokenIndex];
                const progress = (token.start / text.length) * 100;
                
                scanner.style.left = `${progress}%`;
                tokenInfo.textContent = `Token ${currentTokenIndex + 1}/${tokens.length}: "${token.text}" (${token.type})`;
                
                currentTokenIndex++;
                setTimeout(animateToken, 800);
            }
            
            setTimeout(animateToken, 500);
        }
        
        // Event listeners
        algorithmOptions.forEach(option => {
            option.addEventListener('click', () => {
                algorithmOptions.forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');
                currentAlgorithm = option.dataset.algorithm;
                updateParameters();
            });
        });
        
        tokenizeBtn.addEventListener('click', performTokenization);
        
        // Inicializa√ß√£o
        updateParameters();
    </script>
</body>
</html>